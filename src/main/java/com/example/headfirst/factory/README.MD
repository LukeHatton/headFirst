[TOC]

#### 对“针对接口编程“的新思考

- 我们说针对接口编程，就是为了将具体的实现细节对调用者隐藏，目的是当需求发生改变而不得不修改代码时，将需要改动的范围降到最小。
- 但是想一想工作中一般的情况，虽然现在大家都使用MVC三层模型，但是真的做到“针对接口编程”了吗？答案是并没有。大多数情况下我们并没有将这种“针对接口编程，而非实现”的思想烙印在脑海里，总是用到一个方法，就去impl中创建一个，然后将这个新方法添加到接口中，调用者再去调用这个新方法。
- 这种方式的问题在于，使用controller-service-dao模型的本意在于隔离改变，目的是在发生需要修改代码的情况时将需要修改的范围降到最低。然而，普通程序员的代码发生修改时，却总是要去修改好几层的代码，改来改去最后代码会变成一团乱麻。这就是缺乏设计模式思想导致的后果。



#### 给工厂方法模式（Factory Method Pattern）下个定义

**工厂方法模式**定义了一个创建对象的接口，但由子类决定要实例化的具体是哪一个，工厂方法让类把实例化推迟到子类



演示代码实现逻辑：

#### 简单工厂实现

- 首先实现一个简单的**披萨制作流程**。只涉及到两个类：`Pizza.java`和`OrderPizza.java`。

  > Pizza是定义披萨制作流程的抽象类，另有几个实现类并未在这里列出。
  >
  > OrderPizza是实现“订披萨”这个动作的类，包含创建披萨和制作披萨。

- 然后，使用简单工厂模式重写代码`SimplePizzaFactory.java`

  > 简单工厂很难称作是一个“模式”，因为它太简单太普遍了，基本就是普通的抽取共同代码。
  >
  > 怎么使用简单工厂呢？只需将原先`OrderPizza.java`中创建`Pizza`对象的代码抽取到工厂中做就可以了。

#### 现在各地加盟店想实现自己的披萨改良...

- 需要将`OrderPizza.java`改为`PizzaStore.java`，同时也要变成抽象类，供各个加盟店自己实现创建Pizza的逻辑
- 通过这样做，就将不同地区不同加盟店的实现逻辑交给他们自己去实现了，作为调用者，只需要关注`PizzaStore`中的实现即可。在现在的`PizzaStore`实现中，它通过定义一个需要子类实现的抽象方法，**来将实例化产品的责任移动到方法中**，由子类在抽象方法的实现中决定实例化的产品，**此方法就如同是一个”工厂“**，并在具体方法中使用这个产品。这就是”**工厂方法**“模式

------

#### 仔细观察工厂方法(Factory Method)

```java
# abstract:工厂方法是抽象的
# Product:工厂方法必须返回一个产品。超类中预定义的方法通常使用到工厂方法的返回值
# factoryMethod:工厂方法将客户（即超类调用到此方法的代码）和实际创建具体产品的代码分隔开来
# String param:工厂方法可能需要参数，也可能不需要，视情况而定
abstract Product factoryMethod(String param)
```

------

### 设计原则

- 依赖倒置原则（Dependency Inversion Principle）：要依赖抽象，不要依赖具体实现

  > 是不是听起来和“针对接口编程，不要针对实现编程”很像？确实很像，但**这条设计原则更加强调“抽象”**。
  >
  > 这个原则说明了，无论高层还是底层组件，两者都应依赖于抽象
  >
  > - 问:什么是“高层组件”？
      >
      >   答：所谓高层组件，就是由其他低层组件定义其行为的类。在披萨例子中，`PizzaStore`就是个高层组件，它的行为是由`Pizza`定义的，而`Pizza`本身属于低层组件，因为它没有什么额外的依赖。
  >
  > - 问：依赖倒置，究竟是怎么个“倒置”法？到底是倒置了什么？
      >
      >   答：**倒置的是通常的思维方式。**
      >
      >   想一想，我们通常在思考业务实现逻辑时，是不是都是从顶层出发的？“我有这样一个需求，我需要怎样怎样去实现它，需要创建什么什么类，可能还有一些enum”，这就是通常的思考方式。
      >
      >   其实，在这里多想一点，在想好了基本的实现方案后，再想一想有没有底层组件可以抽取出来的通用的抽象部分，然后高层代码（即调用者）和底层实现都去依赖这个抽象，这就是依赖倒置了。

- 尽量遵循依赖倒置原则的要点

    - **变量不可以持有具体类的引用**

      > `new`关键字就是判别是否引用了具体类的关键。可以通过使用工厂来避免使用`new`

    - **不要让类派生自具体类**

      > 如果你的类派生自具体类，自然就会依赖具体类。一定要派生于抽象

    - **不要覆盖基类中已经实现了的方法**

      > 如果发现需要覆盖基类中的方法，那么你的基类就不是一个设计良好的适合被继承的抽象。
      >
      > 基类中实现的方法，应该能被所有子类共享

### 抽象工厂

- **抽象工厂模式提供一个接口，用来创建相关或依赖对象的家族，而不需要明确指定具体类**
- 通俗来说，抽象工厂允许客户使用抽象的接口创建一组相关的产品，而不需要知道实际产出的产品具体是什么，这样一来，客户就从具体的产品中被解耦
- 因此，工厂方法正是抽象工厂的一个组成部分，两者经常一起使用

#### **对比工厂方法与抽象方法**

|              |             工厂方法             |               抽象方法               |
| :----------: | :------------------------------: | :----------------------------------: |
|   本身类型   |              抽象类              |                 接口                 |
| 子类如何实现 |             extends              |            implementation            |
|     目标     | 将用户代码与**实际产品类型**解耦 | 将用户代码**与产品族的实际类型**解耦 |

==图表描述见Head First P160~161==