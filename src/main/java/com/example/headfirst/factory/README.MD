#### 对“针对接口编程“的新思考

- 我们说针对接口编程，就是为了将具体的实现细节对调用者隐藏，目的是当需求发生改变而不得不修改代码时，将需要改动的范围降到最小。
- 但是想一想工作中一般的情况，虽然现在大家都使用MVC三层模型，但是真的做到“针对接口编程”了吗？答案是并没有。大多数情况下我们并没有将这种“针对接口编程，而非实现”的思想烙印在脑海里，总是用到一个方法，就去impl中创建一个，然后将这个新方法添加到接口中，调用者再去调用这个新方法。
- 这种方式的问题在于，使用controller-service-dao模型的本意在于隔离改变，目的是在发生需要修改代码的情况时将需要修改的范围降到最低。然而，普通程序员的代码发生修改时，却总是要去修改好几层的代码，改来改去最后代码会变成一团乱麻。这就是缺乏设计模式思想导致的后果。



演示代码实现逻辑：

#### 简单工厂实现

- 首先实现一个简单的**披萨制作流程**。只涉及到两个类：`Pizza.java`和`OrderPizza.java`。

  > Pizza是定义披萨制作流程的抽象类，另有几个实现类并未在这里列出。
  >
  > OrderPizza是实现“订披萨”这个动作的类，包含创建披萨和制作披萨。

- 然后，使用简单工厂模式重写代码`SimplePizzaFactory.java`

  > 简单工厂很难称作是一个“模式”，因为它太简单太普遍了，基本就是普通的抽取共同代码。
  >
  > 怎么使用简单工厂呢？只需将原先`OrderPizza.java`中创建`Pizza`对象的代码抽取到工厂中做就可以了。

#### 现在各地加盟店想实现自己的披萨改良...

- 需要将`OrderPizza.java`改为`PizzaStore.java`，同时也要变成抽象类，供各个加盟店自己实现创建Pizza的逻辑
- 通过这样做，就将不同地区不同加盟店的实现逻辑交给他们自己去实现了，作为调用者，只需要关注`PizzaStore`中的实现即可。在现在的`PizzaStore`实现中，它通过定义一个需要子类实现的抽象方法，**来将实例化产品的责任移动到方法中**，由子类在抽象方法的实现中决定实例化的产品，**此方法就如同是一个”工厂“**，并在具体方法中使用这个产品。这就是”**工厂方法**“模式

------

#### 仔细观察工厂方法

```java
# abstract:工厂方法是抽象的
# Product:工厂方法必须返回一个产品。超类中预定义的方法通常使用到工厂方法的返回值
# factoryMethod:工厂方法将客户（即超类调用到此方法的代码）和实际创建具体产品的代码分隔开来
# String param:工厂方法可能需要参数，也可能不需要，视情况而定
abstract Product factoryMethod(String param)
```

