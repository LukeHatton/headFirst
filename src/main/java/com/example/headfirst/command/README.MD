命令模式

- 将**发出请求的对象**与**接受并执行请求的对象**分隔开来
- 想一想经常用到的各种`execute()`方法（比如RedisTemplate），岂不就是命令模式的典型应用？用户代码只需要传入参数或者定义函数，并调用`execute()`就行了，不需要关注命令是如何被执行的
- 再想一想，java中的多线程任务实现，`Runnable`和`Callable`，实现思想不也是如此？我们只需传入要运行的函数体（即动作对象），然后在需要执行的时候execute就行了

定义命令模式

- 命令模式将请求封装成对象，以便使用不同的请求、队列、或日志来参数化其他对象。命令模式也支持可撤销的操作

**命令模式中的角色：**

- Client：客户端代码，负责对Invoker发出请求
- Command：命令对象，用来抽象被发出的命令本身
- Invoker：持有Command对象，并在某个时候调用其`execute()`方法
- Receiver：命令的真正执行者，知道该怎样执行一个具体的动作（即action）

**命令模式的最大特点：撤销操作**

- 如果没有撤销操作，命令模式也不过只是面向抽象编程指导思想的简单实现而已
- 在编辑撤销操作时，必须要考虑到一个严肃的问题：**有状态的对象**。撤销操作应该能恢复对象的状态
- 如何实现多次撤销呢？很简单，只要使用堆栈存储命令即可，每次撤销都取出栈顶的最后一条命令执行undo

**将命令组合起来！——宏命令（Macro Command）**



使用动态代理生成命令对象成功了，但是还有一点小问题：方法上的注解必须加在接口上，因为JDK动态代理无法得到实现类方法上的注解（因为是基于接口的动态代理）

